000000:		    . = 100                     ; данные располагаются с 100 адреса
000100:		A:  .BYTE 34, 12, -1, 66, -2    ; массив (A - константа, равна адресу 100), сумма = 131, так как все числа восьмеричные
	    034
	 012
	    377
	 066
	    376
000105:		    . = 107                     ; по адресу 106 дожен лежать 0, тогда сумма массива будет равна 131
000107:		    .BYTE 1, 0
	 001
	    000
000111:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000111:		; Sum all data in the A array and store the summ into R0
000111:		;    R0 - sum
000111:		;    R2 - address
000111:		;    R3 - (byte)A[R1]
000111:		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
000111:		    .=1000                     ; код располагается с 1000 адреса
001000:		    mov #A, R2                 ; R2 - адрес начала массива
	 012702
	 000100
001004:		    clr R0                     ; R0 = 0
	 005000
001006:		    
001006:		LOOP:
001006:		    movb (R2)+, R3             ; R3 = *R2; R2++ записывает в R3 число, лежащее по адресу, хранимому в R2, этот адрес увеличивается
	 112203
001010:		    beq END
	 001402
001012:		    add R3, R0                 ; очередное число прибавляется к текущей сумме
	 060300
001014:		    br LOOP
	 000774
001016:		END:    
001016:		    halt
	 000000
